#+TITLE: LeetCode-移除元素
#+CATEGORIES: LeetCode
#+DESCRIPTION: 每天一题LeetCode
#+KEYWORDS: LeetCode,Java
#+DATE: 2018-10-31 13:43

* Easy-移除元素

** 题目描述
给定一个数组 ~nums~ 和一个值 ~val~ ，你需要原地移除所有数值等于 ~val~ 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 $O(1)$ 额外空间的条件下完成。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

** 示例 1:
给定 ~nums = [3,2,2,3]~ , ~val = 3~ ,

函数应该返回新的长度 2, 并且 ~nums~ 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。

** 示例 2:
给定 ~nums = [0,1,2,2,3,0,4,2]~ , ~val = 2~ ,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。

* 自己解答
** 思路
1. 使用昨天刷的题 [[https://www.cnblogs.com/devinkin/p/9876241.html#orgd3f6712][删除排序数组中的重复项]] 中的学到的方法,双指针法
2. 用i作为慢指针,j作为快指针,遍历数组.
3. 当 $nums[j] \not= val$, 将 ~nums[j]~ 复制到 ~nums[i]~,同时递增i和j,直到j达到数组尾部.
4. 数组的新长度为i.
** 代码
#+BEGIN_SRC java
package algorithm.easy;

public class RemoveElement {
    public static int solution(int[] nums, int val) {
        int i = 0;
        // i 是慢指针,j是快指针
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] != val) {
                // 如果不是val,将当前值放在数组首部,慢指针加1
                nums[i] = nums[j];
                i++;
            }
        }
        return i;
    }

    public static void main(String[] args) {
        int[] nums1 = new int[] {3,2,2,3};
        int[] nums2 = new int[] {0,1,2,2,3,0,4,2};
        System.out.println(solution(nums1, 3));
        System.out.println(solution(nums2, 2));
    }
}
#+END_SRC

** 反思
1. 数组中包含很少的要删除的元素,算法会对数组前面的几个元素做不必要的复制操作.

* 官方解答

** 方法一：双指针
*** 思路
- 既然问题要求我们就地删除给定值的所有元素，我们就必须用 $O(1)$ 的额外空间来处理它。如何解决？我们可以保留两个指针 ~i~ 和 ~j~ ，其中 ~i~ 是慢指针， ~j~ 是快指针。

*** 算法

1. 当 ~nums[j]~ 与给定的值相等时，递增 ~j~ 以跳过该元素。只要 $nums[j] \neq val$ ，
我们就复制 ~nums[j]~ 到 ~nums[i]~ 并同时递增两个索引。重复这一过程，直到 ~j~ 到达数组的末尾，该数组的新长度为 ~i~ 。

2. 该解法与 删除排序数组中的重复项 的解法十分相似。


*** 复杂度分析

1. 时间复杂度：$O(n)$ ， 假设数组总共有 ~n~ 个元素，~i~ 和 ~j~ 至少遍历 ~2n~ 步。

2. 空间复杂度：$O(1)$ 。 


** 方法二：双指针 —— 当要删除的元素很少时
*** 思路
1. 现在考虑数组包含很少的要删除的元素的情况。例如， ~num=[1，2，3，5，4]~ ， ~Val=4~ 。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 ~num=[4，1，2，3，5]~ ， ~Val=4~ 。似乎没有必要将 ~[1，2，3，5]~ 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。

*** 算法

1. 当我们遇到 ~nums[i] = val~ 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。

2. 请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。


*** 复杂度分析

1. 时间复杂度：$O(n)$ ， ~i~ 和 ~n~ 最多遍历 ~n~ 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。

2. 空间复杂度： ~O(1)~ 。
